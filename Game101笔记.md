# （3）矩阵变换

## 如何构建旋转矩阵

![RotationMatrix](./Game101Pic/RotationMatrix.png)

因为约定的是列向量形式，因此第一列表示基向量(1, 0)旋转之后的结果，第二列是基向量(0, 1)旋转之后的结果。

## 什么是齐次坐标？

齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示，简单说就是升维，比如2维的矩阵变成了3维矩阵。

## 为什么需要齐次坐标？

![Translation](./Game101Pic/Translation.png)

如上图所示，如果使用2维的矩阵无法进行平移操作，这对于想通过矩阵的组合实现复杂变换是不方便的。因此通过齐次坐标引入n+1维达到实现平移的目的。

![AffineTransformations](./Game101Pic/AffineTransformations.png)

## 向量或者点如何变成齐次坐标？

![AddCoordinate](./Game101Pic/AddCoordinate.png)

这里的规则是如果是Point那么添加的那一个轴的数值是1，如果是Vector则为0，这样约定有什么好处呢？

* 点如果应用平移操作则会改变点的位置，而向量只有方向性因此平移后点的位置不变。

  ![PointApplyMatrix](./Game101Pic/PointApplyMatrix.png)

  ![VectorApplyMatrix](./Game101Pic/VectorApplyMatrix.png)

* 依然能够满足点和向量的基本性质
  ![Homogenous](./Game101Pic/Homogenous.png)

## 列向量应用矩阵的顺序从右到左

![ComposingOrder](./Game101Pic/ComposingOrder.png)

## 如果围绕一个指定的点旋转？

![DecomposingComplexTransforms](./Game101Pic/DecomposingComplexTransforms.png)

先将指定的点平移到(0, 0)点，然后旋转，最后在平移回原来的位置

## 先线性变换再平移

![LinearTransformFirst](./Game101Pic/LinearTransformFirst.png)

![LinearTransformFirst1](./Game101Pic/LinearTransformFirst1.png)

可以看到先线性变换最后再加上平移变换

# (4) Transformation Cont

正交矩阵性质：逆矩阵和转置矩阵为同一矩阵

![正交矩阵的性质](./Game101Pic/正交矩阵.png)

绕固定坐标轴旋转的公式：

![绕固定坐标轴旋转的公式](./Game101Pic/绕固定坐标轴旋转的公式.png)

绕通过原点的任意轴旋转公式：

![绕通过原点的任意轴旋转公式](./Game101Pic/绕通过原点的任意轴旋转公式.png)

>_四元数一个主要的用途在于插值方便_


变换中的MVP,模型变换，视角变换，投影变换

![MVP变换之前的情况](./Game101Pic/MVP变换之前的情况.png)

![MVP变换之后的情况，Y为Up, -Z为Lookat](./Game101Pic/MVP变换之后的情况.png)

变换之后处理问题变的简单。

大概步骤：
1. 所有模型和相机移动到原点（Y为Up, -Z为Lookat）
2. 正交/投影变换
3. 缩放到[-1, 1]区间
4. 视口变换

想到正交投影的Z处理，一般会直接弃掉Z, 但标准做法是上面的步骤3，会映射到[-1, 1]的立方体中。

![正交投影的矩阵](./Game101Pic/正交投影的矩阵.png)



透视投影推导这里的思想是先把透视投影四棱锥挤压成正交投影的长方体

![挤压成长方体](./Game101Pic/挤压成长方体.png)


对于视椎体内Z值上平面的每一点，x y变换之后的结果为：

![透视投影推导1](./Game101Pic/透视投影推导1.png)

![透视投影推导2](./Game101Pic/透视投影推导2.png)

因此我们知道（x, y, z, 1）经过矩阵变换后可以得到（nx, ny, ?, z）, 通过这些信息可以大概猜测出矩阵的样子

![透视投影推导3](./Game101Pic/透视投影推导3.png)

![透视投影推导4](./Game101Pic/透视投影推导4.png)

还有4个未知数字，我们已知在挤压过程中有两个不变的现象：

挤压过程中的不变式：
1. n平面不变
2. f平面Z不变

因此（x, y, n, 1）经过矩阵变换后应该得到（x, y, n, z）即（nx, ny, n*n, n）, 想要达到这种效果，4个未知数的前两个必须是0

![透视投影推导5](./Game101Pic/透视投影推导5.png)

再利用不变式2，得到剩余两个未知数的数值：

![透视投影推导6](./Game101Pic/透视投影推导6.png)

透视转正交的矩阵为：

![透视转正交的矩阵形式](./Game101Pic/透视转正交的矩阵形式.png)

作业：四棱锥中的任意点变换之后Z是靠近相机还是远离相机？

答案：远离

![Z轴上的一点经过变换](./Game101Pic/MVP变换作业1.png)

计算出的Z与X相减得到：

![Z轴上的一点经过变换](./Game101Pic/MVP变换作业2.jpg)


为什么不是Z不变? 很多人都有这样的疑问，我们按照上面的思路可以计算一下。

如果满足以上所有条件并且Z在转换过程中不变的话会得到下面这个矩阵结果：

![MVP变换作业思考](./Game101Pic/MVP变换作业思考.png)

可以看到这个矩阵中夹带了一个变量z，是一个随着向量不同而时刻变化的矩阵，这不是一个由n和f等常量组成的矩阵，因此一开始的假设(假设一定是一个矩阵并且矩阵各项由已知常量组成)就决定了Z肯定要变化的。

# (5) Rasterization 1 (Triangles)

之前定义视椎体需要用到n, f, l, r, t, b六个变量，实际中只需宽高比(Aspect ratio)和FOV(垂直方向)即可。

![定义视椎体所需的变量](./Game101Pic/定义视椎体所需的变量.png)

l，r, t, b都可以通过宽高比和FOV转换得到(n, f需要知道才能得到四棱锥的信息)：

![通过宽高比和FOV计算其他参数](./Game101Pic/通过宽高比和FOV计算其他参数.png)

光栅化的意思就是画到屏幕上

上一节经过MVP变换后得到[-1, 1]的立方体，现在需要做最后的视口变换，即变换到原点(0, 0)在左下角，宽高为Width, Height的屏幕空间上(Z暂时不做任何处理)：

![视口变换](./Game101Pic/视口变换1.png)

![视口变换](./Game101Pic/视口变换2.png)


>_显示屏幕是如何显示出来内容的？显存中有一块内存区域，我们可以告诉显卡现在哪块内存用于映射到屏幕上(可以利用双缓存)_

三角形的优势：

* 最简单基础的多边形
* 其他多边形可以分解成若干个三角形
* 一定同面
* 内外定义清晰
* 三个顶点有不同的属性，内部可以平滑插值
  
视口变换后我们得到了需要显示的若干些三角形，接下来的问题是判断**像素和三角形的位置关系**，更准确的说是像素的中心点和三角形的位置关系；

采样是一个把函数离散化的过程。

我们定义一个采样的函数：判断某个像素点是否在某个三角形内：

func = inside(tri, x, y)

有了这个采样函数后，我们可以遍历整个屏幕所有的像素点，查询每个像素中心点是否在三角形内：

![采样的简单过程](./Game101Pic/采样的简单过程.PNG)

如何判断一个点是否在三角形内呢？三角形ABC和点P，如果AB叉乘AP, BC叉乘BP, CA叉乘CP结果的Z分量同方向则在三角形内，否则三角形外

上面提到了对于每个三角形都要遍历所有像素点，这里有一个加速方法是只遍历三角形的AABB包围盒：

![只遍历三角形AABB的区域](./Game101Pic/只遍历三角形AABB的区域.PNG)

通过遍历我们想要在屏幕上显示这个三角形：

![想要显示的三角形](./Game101Pic/想要显示的三角形.PNG)

通过采样计算后得到的是：

![采样后得到的实际结果](./Game101Pic/采样后得到的实际结果.PNG)

这就引出了图形学一直致力解决的一个问题：抗锯齿(反走样)技术，根源在于采样率不够。

![典型的锯齿问题](./Game101Pic/典型的锯齿问题.png)

>_问题：所以光栅化的过程是遍历视口变换后的所有三角形，对于每个三角形都要遍历所有像素点，查询该像素点是否在三角形内？_


# （6）Rasterization2(Antialiasing and Z-Buffering)

这里做了一个很有意思的试验，把偶数行列数据抽掉就会删除走样问题，**根源在于信号在很高频地变化而采样率太低**

![摩尔纹](./Game101Pic/摩尔纹.PNG)

先说结论：**先模糊再采样可以很好的解决走样问题**

下面两幅图做下对比：

直接采样可以看到像素点非红即白，这会造成走样问题。

![像素点非红即白](./Game101Pic/像素点非红即白.PNG)

先模糊再采样可以看到三角形边缘位置有红白的中间色

>_可以理解成锯齿边缘不再是那么硬的转换了，而是有过渡色了_

![先模糊再采样](./Game101Pic/先模糊再采样.PNG)

这里提到先采样再模糊是错误的做法。

![先采样后模糊是错误的方法](./Game101Pic/先采样后模糊是错误的方法.PNG)

接下来花了很长的时间来解释如何从信号处理的角度解释什么是走样，什么情况下会出现走样。

任何函数f(x)都可以进行傅里叶展开，即任何函数都可以变换为sin(x)和cos(x)的组合：

![傅里叶变换概述](./Game101Pic/傅里叶变换概述.PNG)

我们可以对任何函数f(x)进行傅里叶变换得到F(x)，又可以对F(x)进行反傅里叶变换变回f(x)

![傅里叶变换和反傅里叶变换](./Game101Pic/傅里叶变换的反傅里叶变换.PNG)

最大的意义在于**时域到频域的相互转换**

信号处理的角度下认为什么是走样呢？在一个给定的采样率下，无法区分两条不同频率的信号时，这种现象就叫走样。

![信号处理的角度理解走样](./Game101Pic/信号处理的角度理解走样.PNG)

接下来我们对图片做傅里叶变换，可视化的说明高频和低频

![对图片应用傅里叶变换](./Game101Pic/对图片应用傅里叶变换.PNG)

中心的光亮图是低频信息，而外边的白线和白点是高频信息

我们手动把右边的低频数据抹掉然后再反傅里叶变换回图片上，可以得到如下结果：

![高通滤波器](./Game101Pic/高通滤波器.PNG)

可以看到一些图片中的边缘数据保留了下来，这就说明**高频信息对应的是数据发生突变的那部分信息**，对应到图片就是轮廓数据。

