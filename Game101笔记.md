# （3）矩阵变换

## 如何构建旋转矩阵

![RotationMatrix](./Game101Pic/RotationMatrix.png)

因为约定的是列向量形式，因此第一列表示基向量(1, 0)旋转之后的结果，第二列是基向量(0, 1)旋转之后的结果。

## 什么是齐次坐标？

齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示，简单说就是升维，比如2维的矩阵变成了3维矩阵。

## 为什么需要齐次坐标？

![Translation](./Game101Pic/Translation.png)

如上图所示，如果使用2维的矩阵无法进行平移操作，这对于想通过矩阵的组合实现复杂变换是不方便的。因此通过齐次坐标引入n+1维达到实现平移的目的。

![AffineTransformations](./Game101Pic/AffineTransformations.png)

## 向量或者点如何变成齐次坐标？

![AddCoordinate](./Game101Pic/AddCoordinate.png)

这里的规则是如果是Point那么添加的那一个轴的数值是1，如果是Vector则为0，这样约定有什么好处呢？

* 点如果应用平移操作则会改变点的位置，而向量只有方向性因此平移后点的位置不变。

  ![PointApplyMatrix](./Game101Pic/PointApplyMatrix.png)

  ![VectorApplyMatrix](./Game101Pic/VectorApplyMatrix.png)

* 依然能够满足点和向量的基本性质
  ![Homogenous](./Game101Pic/Homogenous.png)

## 列向量应用矩阵的顺序从右到左

![ComposingOrder](./Game101Pic/ComposingOrder.png)

## 如果围绕一个指定的点旋转？

![DecomposingComplexTransforms](./Game101Pic/DecomposingComplexTransforms.png)

先将指定的点平移到(0, 0)点，然后旋转，最后在平移回原来的位置

## 先线性变换再平移

![LinearTransformFirst](./Game101Pic/LinearTransformFirst.png)

![LinearTransformFirst1](./Game101Pic/LinearTransformFirst1.png)

可以看到先线性变换最后再加上平移变换

# (4) Transformation Cont

正交矩阵性质：逆矩阵和转置矩阵为同一矩阵

![正交矩阵的性质](./Game101Pic/正交矩阵.png)

绕固定坐标轴旋转的公式：

![绕固定坐标轴旋转的公式](./Game101Pic/绕固定坐标轴旋转的公式.png)

绕通过原点的任意轴旋转公式：

![绕通过原点的任意轴旋转公式](./Game101Pic/绕通过原点的任意轴旋转公式.png)

>_四元数一个主要的用途在于插值方便_


变换中的MVP,模型变换，视角变换，投影变换

![MVP变换之前的情况](./Game101Pic/MVP变换之前的情况.png)

![MVP变换之后的情况，Y为Up, -Z为Lookat](./Game101Pic/MVP变换之后的情况.png)

变换之后处理问题变的简单。

大概步骤：
1. 所有模型和相机移动到原点（Y为Up, -Z为Lookat）
2. 正交/投影变换
3. 缩放到[-1, 1]区间
4. 视口变换

想到正交投影的Z处理，一般会直接弃掉Z, 但标准做法是上面的步骤3，会映射到[-1, 1]的立方体中。

![正交投影的矩阵](./Game101Pic/正交投影的矩阵.png)



透视投影推导这里的思想是先把透视投影四棱锥挤压成正交投影的长方体

![挤压成长方体](./Game101Pic/挤压成长方体.png)


对于视椎体内Z值上平面的每一点，x y变换之后的结果为：

![透视投影推导1](./Game101Pic/透视投影推导1.png)

![透视投影推导2](./Game101Pic/透视投影推导2.png)

因此我们知道（x, y, z, 1）经过矩阵变换后可以得到（nx, ny, ?, z）, 通过这些信息可以大概猜测出矩阵的样子

![透视投影推导3](./Game101Pic/透视投影推导3.png)

![透视投影推导4](./Game101Pic/透视投影推导4.png)

还有4个未知数字，我们已知在挤压过程中有两个不变的现象：

挤压过程中的不变式：
1. n平面不变
2. f平面Z不变

因此（x, y, n, 1）经过矩阵变换后应该得到（x, y, n, z）即（nx, ny, n*n, n）, 想要达到这种效果，4个未知数的前两个必须是0

![透视投影推导5](./Game101Pic/透视投影推导5.png)

再利用不变式2，得到剩余两个未知数的数值：

![透视投影推导6](./Game101Pic/透视投影推导6.png)

透视转正交的矩阵为：

![透视转正交的矩阵形式](./Game101Pic/透视转正交的矩阵形式.png)

作业：四棱锥中的任意点变换之后Z是靠近相机还是远离相机？

答案：远离

![Z轴上的一点经过变换](./Game101Pic/MVP变换作业1.png)

计算出的Z与X相减得到：

![Z轴上的一点经过变换](./Game101Pic/MVP变换作业2.jpg)


为什么不是Z不变? 很多人都有这样的疑问，我们按照上面的思路可以计算一下。

如果满足以上所有条件并且Z在转换过程中不变的话会得到下面这个矩阵结果：

![MVP变换作业思考](./Game101Pic/MVP变换作业思考.png)

可以看到这个矩阵中夹带了一个变量z，是一个随着向量不同而时刻变化的矩阵，这不是一个由n和f等常量组成的矩阵，因此一开始的假设(假设一定是一个矩阵并且矩阵各项由已知常量组成)就决定了Z肯定要变化的。

# (5) Rasterization 1 (Triangles)

之前定义视椎体需要用到n, f, l, r, t, b六个变量，实际中只需宽高比(Aspect ratio)和FOV(垂直方向)即可。

![定义视椎体所需的变量](./Game101Pic/定义视椎体所需的变量.png)

l，r, t, b都可以通过宽高比和FOV转换得到(n, f需要知道才能得到四棱锥的信息)：

![通过宽高比和FOV计算其他参数](./Game101Pic/通过宽高比和FOV计算其他参数.png)

光栅化的意思就是画到屏幕上

上一节经过MVP变换后得到[-1, 1]的立方体，现在需要做最后的视口变换，即变换到原点(0, 0)在左下角，宽高为Width, Height的屏幕空间上(Z暂时不做任何处理)：

![视口变换](./Game101Pic/视口变换1.png)

![视口变换](./Game101Pic/视口变换2.png)


>_显示屏幕是如何显示出来内容的？显存中有一块内存区域，我们可以告诉显卡现在哪块内存用于映射到屏幕上(可以利用双缓存)_

三角形的优势：

* 最简单基础的多边形
* 其他多边形可以分解成若干个三角形
* 一定同面
* 内外定义清晰
* 三个顶点有不同的属性，内部可以平滑插值
  
视口变换后我们得到了需要显示的若干些三角形，接下来的问题是判断**像素和三角形的位置关系**，更准确的说是像素的中心点和三角形的位置关系；

采样是一个把函数离散化的过程。

我们定义一个采样的函数：判断某个像素点是否在某个三角形内：

func = inside(tri, x, y)

有了这个采样函数后，我们可以遍历整个屏幕所有的像素点，查询每个像素中心点是否在三角形内：

![采样的简单过程](./Game101Pic/采样的简单过程.PNG)

如何判断一个点是否在三角形内呢？三角形ABC和点P，如果AB叉乘AP, BC叉乘BP, CA叉乘CP结果的Z分量同方向则在三角形内，否则三角形外

上面提到了对于每个三角形都要遍历所有像素点，这里有一个加速方法是只遍历三角形的AABB包围盒：

![只遍历三角形AABB的区域](./Game101Pic/只遍历三角形AABB的区域.PNG)

通过遍历我们想要在屏幕上显示这个三角形：

![想要显示的三角形](./Game101Pic/想要显示的三角形.PNG)

通过采样计算后得到的是：

![采样后得到的实际结果](./Game101Pic/采样后得到的实际结果.PNG)

这就引出了图形学一直致力解决的一个问题：抗锯齿(反走样)技术，根源在于采样率不够。

![典型的锯齿问题](./Game101Pic/典型的锯齿问题.png)

>_问题：所以光栅化的过程是遍历视口变换后的所有三角形，对于每个三角形都要遍历所有像素点，查询该像素点是否在三角形内？_


# （6）Rasterization2(Antialiasing and Z-Buffering)

这里做了一个很有意思的试验，把偶数行列数据抽掉就会删除走样问题，**根源在于信号在很高频地变化而采样率太低**

![摩尔纹](./Game101Pic/摩尔纹.PNG)

先说结论：**先模糊再采样可以很好的解决走样问题**

下面两幅图做下对比：

直接采样可以看到像素点非红即白，这会造成走样问题。

![像素点非红即白](./Game101Pic/像素点非红即白.PNG)

先模糊再采样可以看到三角形边缘位置有红白的中间色

>_可以理解成锯齿边缘不再是那么硬的转换了，而是有过渡色了_

![先模糊再采样](./Game101Pic/先模糊再采样.PNG)

这里提到先采样再模糊是错误的做法。

![先采样后模糊是错误的方法](./Game101Pic/先采样后模糊是错误的方法.PNG)

接下来花了很长的时间来解释如何从信号处理的角度解释什么是走样，什么情况下会出现走样。

任何函数f(x)都可以进行傅里叶展开，即任何函数都可以变换为sin(x)和cos(x)的组合：

![傅里叶变换概述](./Game101Pic/傅里叶变换概述.PNG)

我们可以对任何函数f(x)进行傅里叶变换得到F(x)，又可以对F(x)进行反傅里叶变换变回f(x)

![傅里叶变换和反傅里叶变换](./Game101Pic/傅里叶变换的反傅里叶变换.PNG)

最大的意义在于**时域到频域的相互转换**

信号处理的角度下认为什么是走样呢？在一个给定的采样率下，无法区分两条不同频率的信号时，这种现象就叫走样。

![信号处理的角度理解走样](./Game101Pic/信号处理的角度理解走样.PNG)

## 滤波器就是处理掉某种频率的信息

接下来我们对图片做傅里叶变换，可视化的说明高频和低频

![对图片应用傅里叶变换](./Game101Pic/对图片应用傅里叶变换.PNG)

中心的光亮图是低频信息，而外边的白线和白点是高频信息

我们手动把右边的低频数据抹掉然后再反傅里叶变换回图片上，可以得到如下结果：

![高通滤波器](./Game101Pic/高通滤波器.PNG)

可以看到一些图片中的边缘数据保留了下来，这就说明**高频信息对应的是数据发生突变的那部分信息**，对应到图片就是轮廓数据。

继续看下低通滤波器的效果：

![低通滤波器](./Game101Pic/低通滤波器.PNG)

低通滤波器的效果就是做了类似模糊操作的处理。

## 滤波器也是一种卷积(加权平均)

这里的卷积就是图像处理中的卷积核，是一种狭义的解释

![卷积的一种狭义解释](./Game101Pic/卷积的一种狭义解释.png)

**卷积定理：两个函数时域上的卷积等于频域上的乘积，反之亦然**

![卷积定理的例子](./Game101Pic/卷积定理的例子.png)

可以看到上面使用卷积核在时域上做了卷积操作，我们也可以先将图片通过傅里叶变换转换到频域上，同时也将卷积核做傅里叶变换，然后将这两个结果相乘，然后再反傅里叶变换也能得到相同的结果。

## 采样就是重复频域上的内容

![采样就是重复频域上的内容](./Game101Pic/采样就是重复频域上的内容.png)

左边图就是两个函数时域上的乘积，右边是他们频域上的卷积，右下角的图可以看到采样就是重复频域上的内容，接下来看下信号处理的角度是如何判断是否产生走样的。

![频域内容发生重叠就必然产生走样](./Game101Pic/频域内容发生重叠就必然产生走样.png)

**只要重复频域上的内容发生了重叠就必然会产生走样**

知道了产生的原因，我们接下来看下如何解决走样问题

## 反走样

![反走样的具体办法](./Game101Pic/反走样的具体办法.PNG)

一种是增加采样率，这样在Repeat Content时间隔会增加，或者采用高分辨率显示设备，这种代价比较昂贵。另外一种就是让区域内容变的“窄”一些，办法就是去掉高频内容，即模糊操作。

![先变窄然后再重复](./Game101Pic/先变窄然后再重复.PNG)

具体到反走样步骤如下：

![反走样具体步骤1](./Game101Pic/反走样具体步骤1.PNG)

![反走样具体步骤2](./Game101Pic/反走样具体步骤2.PNG)

![反走样具体步骤3](./Game101Pic/反走样具体步骤3.PNG)

就是不再简单的判断像素中心点在三角形内就是红色，不在就是白色，而是看覆盖面积是多少，面积作为权重计算颜色(白色到红色), 通过覆盖面积计算颜色值其实本质也是一种卷积核，覆盖面积如何粗略计算或者说这个卷积核长什么样子，可以参考下面的具体反走样应用MSAA

## Antialiasing By Supersampling(MSAA)

不同的MSAA设置其实就是设置卷积核是什么样子，具体原理还是上面所提到的。

![MSAA4X4的卷积核](./Game101Pic/MSAA4X4的卷积核.PNG)

以MSAA 4X4为例，就是把一个像素点又分成了16个更小的像素点，分别判断这16个像素点是否在三角形内就可以这个大像素点的覆盖面积，然后就是计算最终颜色

>_游戏引擎中的MSAA 4X指的是4个采样点，即2X2_

![MSAA步骤1](./Game101Pic/MSAA步骤1.PNG)

![MSAA步骤2](./Game101Pic/MSAA步骤2.PNG)

![MSAA步骤3](./Game101Pic/MSAA步骤3.PNG)

![MSAA步骤4](./Game101Pic/MSAA步骤4.PNG)

![MSAA步骤5](./Game101Pic/MSAA步骤5.PNG)

![MSAA步骤6](./Game101Pic/MSAA步骤6.PNG)

## 其他有效的办法

FXAA (Fast Approximate AA) 直接对走样进行类似图片反走样的处理

FXAA是快速近似抗锯齿的简称，它是一种简单而高效的抗锯齿方式，对图形边缘进行后处理。它不需要访问深度缓冲或多重采样缓冲，只需要分析每个像素及其邻域信息，识别出锯齿边缘，并对其进行模糊化处理。

TAA(Temporal Anti-Aliasing)的原理是利用相机抖动和历史帧信息来增加像素的采样数。具体来说，对于每一帧游戏画面，相机会在0.x~1像素范围内随机偏移，这样就可以得到当前像素的多个子像素信息。然后，将当前帧和历史帧进行加权融合，得到当前像素的最终颜色。这样就相当于在时域上进行了超采样，提高了图像的分辨率和清晰度。

DLSS的全称是Deep Learning Super Sampling，翻译成中文就是深度学习超级采样，它的作用是通过降低游戏内的渲染分辨率，同时再通过人工智能算法模型和AI加速硬件单元（Tensor Core）来拉伸输出画面，提高显示分辨率，例如使用1080P的渲染分辨率再通过AI算法和Tensor Core运算输出4K（2160P）的显示分辨率，以此来达成提升帧数的目的

# （7）Shading 1 (Illumination, Shading and Graphics Pipeline)

通过上面的步骤我们有很多三角形需要绘制，还肯定有若干些三角形发生重叠，那么最终某个像素是显示哪个三角形上的颜色呢？这就是处理可见性或者遮挡关系。

## 画家算法

从Z远处的地方开始画，然后画偏近的，重复这个过程。

![画家算法](./Game101Pic/画家算法.PNG)

需要先排序，然后又远到近开始画，n个三角形先按照z排序，算法复杂度O(nlg(n)), 但有一种情况无法处理：

![画家算法无法处理的情况](./Game101Pic/画家算法无法处理的情况.PNG)

这就引入了图形学常用的深度缓存算法

## 深度缓存

深度缓存算法有几个要点：

1. 存储的是每个**像素**上的最小深度而不是三角形
2. 运算过程中有两个buffers, 一个是framebuffer存储颜色值，一个是depthbuffer(z-buffer)存储最小深度值
3. framebuffer和depthbuffer是同时生成的(framebuffer肯定要利用depthbuffer的数据决定最终颜色值)
4. 为了简单，我们约定buffer中存储的都是正值，并且越小说明离相机越近

framebuffer和depthbuffer最终生成的效果图：

![FrameBuffer和DepthBuffer](./Game101Pic/FrameBuffer和DepthBuffer.PNG)

深度缓存伪代码如下，可以看到framebuffer正是利用深度缓存才能确定最终这个像素点最终的颜色值：

![深度缓存伪代码](./Game101Pic/深度缓存伪代码.PNG)

一个示例：

![深度缓存示例](./Game101Pic/深度缓存示例.PNG)

深度缓存的几个特点：
1. 算法复杂度为O(n),因为一个三角形可覆盖的像素点是常量，n个三角形需要判断的次数为常量*n
2. 算法无序也是表现正确的，因此不用提前排序
3. GPU硬件都会实现深度缓存算法

>_注意：如果反走样使用了类似MSAA算法的话，在做深度缓存的时候也需要考虑这些采样点而不是单个像素了_


目前为止，我们能通过MVP变换将三角形渲染到屏幕上

![目前所学的内容](./Game101Pic/目前所学的内容.PNG)

如果这时直接填充颜色的话，会得到如下效果：

![无光照的错误显示](./Game101Pic/无光照的错误显示.PNG)

我们期望的是下面这个结果：

![有明暗变化的正确结果](./Game101Pic/有明暗变化的正确结果.PNG)

这就引出了我们要学的Shading, 本节课关于Shading的定义就是：**给不同物品应用不同材质就叫做Shading**

先讲一个最简单的Shading模型即Blinn-Phong Reflectance Model（布林-冯反射模型）

观察下面的图，可以看到茶杯上有三种不同光照表现，在光源一面的地方，接收光的能量最多，反射的也多，这里产生了高光，侧边的地方光线反射到了四面八方产生了漫反射，背面的地方没有直接接收到光照，而是通过其他墙面间接接收到了光照，这种光叫做环境光或者间接光照

![高光漫反射环境光](./Game101Pic/高光漫反射环境光.png)

## 布林-冯反射模型-漫反射项

"Shading Is Local"的含义是**我们在给物体着色时会把这个点看成一个单位平面并且不考虑其他物体的影响(跟光源之间是否有障碍物等等)**，我们考虑的信息有：

* 当前着色点到观察点之间的单位向量v
* 当前着色点的法向量n(单位平面的朝外垂直单位向量)
* 当前着色点到光源(可能很多光源)之间的单位向量l
* 当前着色点的属性（颜色，光泽度/粗糙度等）

下图可以看到接收的能量多少(物体明暗程度)与n和l的cos(θ)有关

![接收的能量与夹角有关](./Game101Pic/接收的能量与夹角有关.PNG)

跟物体接收能量多少相关的还有跟光源之间的距离，光源向外以球型向外辐射能量，离光源越近，单位面积内接收的能量越多，我们知道球的表面积公式是4πr²，如果定义半径1的球体单位面积接收的能量为I,我们需要求半径r单位面积接收的能量，我们假设能量守恒，即4π(1)² * I = 4πr² * X，所以X = I/r²，因此接收的能量跟r²成反比。

![光源辐射后单位面积的能量](./Game101Pic/光源辐射后单位面积的能量.PNG)

通过上面这些分析我们得出一个漫反射模型：

![漫反射模型](./Game101Pic/漫反射模型.PNG)

三个地方注意：

1. max(0, l·n)处理背面的情况
2. kd是一个漫反射系数，0表示吸收不反射，显示就暗，1表示全部反射，显示就亮，也可以扩充为vector，表示颜色(rgb三个通道可以定义就是r,g,b的反射率)
3. 可以看到与向量v无关，这正符合漫反射的定义，因为漫反射反射到各个方向概率是一样的，因此从各个角度看都是一样的

![明暗随着kd不同而不同](./Game101Pic/明暗随着kd不同而不同.PNG)

# （8）Shading 2(Shading, Pipeline and Texture Mapping)

## 布林-冯反射模型-高光项

发生高光的物体一般表面比较光滑，趋近于镜面反射，镜面反射的特点会根据法线方向产生反射，高光产生的原因是观察方向和反射方向接近时会产生高光，如下图中的R和v：

![为何产生高光](./Game101Pic/为何产生高光.PNG)

观察方向和反射方向接近可以等同于法线方向和半程向量接近，半程向量就是光源方向l与观察方向v的和，然后归一化。

![高光项的表达式](./Game101Pic/高光项的表达式.PNG)

高光项有几个注意事项：
1. 引入了观察方向，这区别于漫反射项的公式；
2. 使用半程向量而没有比较观察方向和反射方向，是因为半程向量比较好算，而反射方向的计算相比较而言比较复杂；
3. 公式考虑了能量辐射，而没有考虑能量的吸收，即l和n的夹角，因为是经验公式，确实没有考虑；
4. Ks是高光系数，高光一般显示都是白色，因此Ks的值一般为白色；
5. 比较半程向量与法线方向时使用的是点乘，但可以看到有个p的系数，如下图所示, 是因为一般的cosa的变化比较慢，不加系数的话高光会是一个大的区域，而真实的高光仅仅是一个特别小的高光区域

![高光表达式中的power系数](./Game101Pic/高光表达式中的power系数.PNG)

下图是漫反射+高光后的效果：

![高光加漫反射后的效果](./Game101Pic/高光加漫反射后的效果.PNG)

## 布林-冯反射模型-环境光项

这里直接使用了一个常量表示，I表示能量，Ka表示系数，与光照方向，观察方向，法线方向都无关。这是一个很大胆的假设。

![环境光表达式](./Game101Pic/环境光表达式.PNG)

将漫反射项，高光项和环境光项都加到一起，效果如下：

![布林冯反射模型最终效果](./Game101Pic/布林冯反射模型最终效果.PNG)

## Shading Frequencies（着色频率）

* Flat Shading, 对模型的每个**面**着色，每个面都有相应的法线；
  ![FlatShading](./Game101Pic/FlatShading.PNG)
  >_面的法线可以通过两条边的叉乘所得到_

* Gouraud Shading, 先计算每个顶点的法线，然后对模型的每个**顶点**着色，三角形内部的属性通过重心坐标插值所得；
  ![GouraudShading](./Game101Pic/GouraudShading.PNG)
  >_点的法线如何计算，一个点会紧挨着几个面，可以求这些面的法线和然后求平均即可(也可以使用面的面积加权)_

* Phong Shading, 计算每个像素点的法线，然后对每个**像素**着色；
  ![PhongShading](./Game101Pic/PhongShading.PNG)
  >_像素点的法线如何计算，顶点的法线可以知道，然后三角形内部每个顶点的法线可以通过重心坐标所得_


* 当模型简单时，PhongShading有着更好的结果，但性能也更差；
* 当三角面足够多时，三种着色效果差不多；
* 当模型特别复杂时，甚至三角面数比像素点还要多，那FlatShading的性能可能比PhongShading还要差；
![着色频率的对比](./Game101Pic/着色频率的对比.PNG)

## 实时渲染管线

从模型到显示到屏幕上都经历了哪些流程。

![实时渲染管线概述](./Game101Pic/实时渲染管线概述.PNG)

1. Vertex Processing, 之前所说的MVP变换就是将场景内的顶点转换到屏幕空间上；

2. Triangle Processing, 模型一般在定义时顶点和索引(哪些顶点构成一个三角形)是分开的，因此这个阶段会处理哪些顶点会构成一个三角形；

3. Rasterization，即光栅化处理，上面得到的顶点位置可能还是浮点数，但屏幕上的像素点是离散的，因此光栅化就是将三角形对应到屏幕上的像素点上；

4. Fragment Processing, 如果不考虑MSAA那么Fragment就对应一个像素，如果考虑MSAA的话，那么每个Fragment就是最小的采样点，最终这些采样点会合成一个像素点；这里就是着色处理阶段；

5. FrameBufferOperations, 经过着色处理后，每个像素点都有了颜色信息，显示到屏幕上；    

下面举例说明：

下图是渲染管线中的MVP变换

![渲染管线中的MVP变换](./Game101Pic/渲染管线中的MVP变换.PNG)

下图是渲染管线中的光栅化

![渲染管线中的光栅化](./Game101Pic/渲染管线中的光栅化.PNG)

下图是渲染过程中的ZBuffer测试，测试可以归到光栅化也可以归到着色阶段

![渲染光线中的Z测试](./Game101Pic/渲染光线中的Z测试.PNG)

下图是渲染过程中的着色，可以看到着色即可以发生在顶点处理阶段也可以发生在FragmentProcessing阶段，这是由于选择的着色频率不同而不同，而且现代的实时渲染技术支持可编程着色，可以自定义在哪个阶段如何着色，而需要编写的Shader代码就是处理自定义着色的

![渲染管线中的着色](./Game101Pic/渲染管线中的着色.PNG)

正常情况下我们希望模型的表面是一些纹理效果而不是一些固定颜色，这就需要纹理映射

![渲染过程中的纹理映射](./Game101Pic/渲染过程中的纹理映射.PNG)

## Shader Programs

![Shader的示例](./Game101Pic/Shader的示例.PNG)

* Shader可以发生在顶点处理阶段(VertexShader)也可以是Fragment处理阶段(片元着色器FragmentShader或者PixelShader)；
* 定义了对每个顶点或者Fragment都执行的操作;(区别于顶点1执行这些处理顶点2跳过这些处理，Shader是统一对所有顶点无差别的都执行这些操作，不用写for循环)

下面的例子是一个FragmentShader代码：

![Shader代码示例](./Game101Pic/Shader代码示例.png)

## GPU

分为独立显卡和集成显卡，GPU的一大特点就是并行计算，除了上面说的VertexShader, FramentShader以外还有Geometry Shader以及通用计算的Compute Shader;

## Texture Mapping

因为物体着色时使用的是同一套shader，在渲染时我们希望物体上每个点都有自己的属性，比如颜色，这样的话在应用漫反射公式时Kd的系数不同，这样不同的点渲染出的颜色也不同；Kd不仅仅可以是颜色，也可以是这个点的任何属性；

![物体上每个点都有自己的属性](./Game101Pic/物体上每个点都有自己的属性.PNG)

我们假定3D物体表面可以拆解成多个小的2D图片表示，每个2D图片在一张大的纹理贴图上都有一个2D坐标；

![3D物体表面可以拆解成多个小的2D图片表示](./Game101Pic/3D物体表面可以拆解成多个小的2D图片表示.PNG)

我们看下面纹理映射的例子，每个三角形顶点都有一个记录纹理贴图坐标的属性，具体怎么来指定这种对应关系是由艺术家或者工具来完成。左上角的图只有光的漫反射处理而没有贴图的样子；

![纹理映射的例子](./Game101Pic/纹理映射的例子.PNG)

上面说过的，**每个三角形顶点都有一个记录纹理贴图坐标的属性, 这个属性就叫做u,v**，其实就是x, y，不论这个纹理贴图有多大，uv的范围都是[0, 1]

![纹理坐标可视化例子](./Game101Pic/纹理坐标可视化例子.PNG)

最后要说的是如果贴图设计的好，贴图可以填充多次而不会出现缝隙的问题；

![贴图可以被多次填充](./Game101Pic/贴图可以被多次填充.PNG)

![TiledTextures](./Game101Pic/TiledTextures.PNG)

# （9）Shading 3 (Texture Mapping cont.)

## Barycentric Coordinates(重心坐标)

**重心坐标的目的就是做三角形内的属性插值**

* 为什么需要三角形内插值？上节可以看到很多属性都是在顶点上定义的；
* 需要插值哪些属性？UV坐标(纹理映射)，颜色值(GouraudShading)或者法线向量(PhongShading)等
* 如何插值？利用重心坐标

重心坐标的定义要点：
1. 重心坐标是定义在三角形上的，给出一个三角形有一套重心坐标，换一个三角形另外一套重心坐标；
2. 三角形内任何一点都可以表示成三个顶点的线性组合，即任何一点(x, y) = aA + bB + rC, 同时满足a+b+r=1, 并且a,b,r >= 0;
3. 满足条件后，a,b,r就是点(x,y)在这个三角形内的重心坐标表示，即给定一个三角形，并且给出一个点的重心坐标就可以求出这个点的位置；

![BarycentricCoordinates](./Game101Pic/BarycentricCoordinates.PNG)

重心坐标a,b,r可以通过面积比求出；

![重心坐标可以通过面积比求出](./Game101Pic/重心坐标可以通过面积比求出.PNG)

三角形的重心即a,b,r=1/3的点；

![三角形的重心](./Game101Pic/三角形的重心.PNG)

给出三角形的三个顶点位置以及三角形内任意点位置(x,y)求出a,b,r

![重心坐标公式](./Game101Pic/重心坐标公式.PNG)

有了重心坐标的概念后我们要对属性插值了，下面公式我们知道V=aV(A)+bV(B)+rV(C), 重心坐标定义时V(ABC)都是位置属性，我们可以改为UV属性，颜色，法线，深度等属性信息，有了点的重心坐标，可以对任何属性插值；

![使用重心坐标对属性插值](./Game101Pic/使用重心坐标对属性插值.PNG)

>_警告：三维空间内一个三角形内一个点计算好的重心坐标与通过投影变换后得到的重心坐标有可能是不同的，因此一般会先变换回三维空间然后对其属性插值，老师以深度属性举例_

## 纹理映射

