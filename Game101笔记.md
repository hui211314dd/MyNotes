# （3）矩阵变换

## 如何构建旋转矩阵

![RotationMatrix](./Game101Pic/RotationMatrix.png)

因为约定的是列向量形式，因此第一列表示基向量(1, 0)旋转之后的结果，第二列是基向量(0, 1)旋转之后的结果。

## 什么是齐次坐标？

齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示，简单说就是升维，比如2维的矩阵变成了3维矩阵。

## 为什么需要齐次坐标？

![Translation](./Game101Pic/Translation.png)

如上图所示，如果使用2维的矩阵无法进行平移操作，这对于想通过矩阵的组合实现复杂变换是不方便的。因此通过齐次坐标引入n+1维达到实现平移的目的。

![AffineTransformations](./Game101Pic/AffineTransformations.png)

## 向量或者点如何变成齐次坐标？

![AddCoordinate](./Game101Pic/AddCoordinate.png)

这里的规则是如果是Point那么添加的那一个轴的数值是1，如果是Vector则为0，这样约定有什么好处呢？

* 点如果应用平移操作则会改变点的位置，而向量只有方向性因此平移后点的位置不变。

  ![PointApplyMatrix](./Game101Pic/PointApplyMatrix.png)

  ![VectorApplyMatrix](./Game101Pic/VectorApplyMatrix.png)

* 依然能够满足点和向量的基本性质
  ![Homogenous](./Game101Pic/Homogenous.png)

## 列向量应用矩阵的顺序从右到左

![ComposingOrder](./Game101Pic/ComposingOrder.png)

## 如果围绕一个指定的点旋转？

![DecomposingComplexTransforms](./Game101Pic/DecomposingComplexTransforms.png)

先将指定的点平移到(0, 0)点，然后旋转，最后在平移回原来的位置

## 先线性变换再平移

![LinearTransformFirst](./Game101Pic/LinearTransformFirst.png)

![LinearTransformFirst1](./Game101Pic/LinearTransformFirst1.png)

可以看到先线性变换最后再加上平移变换

# (4) Transformation Cont

正交矩阵性质：逆矩阵和转置矩阵为同一矩阵

![正交矩阵的性质](./Game101Pic/正交矩阵.png)

绕固定坐标轴旋转的公式：

![绕固定坐标轴旋转的公式](./Game101Pic/绕固定坐标轴旋转的公式.png)

绕通过原点的任意轴旋转公式：

![绕通过原点的任意轴旋转公式](./Game101Pic/绕通过原点的任意轴旋转公式.png)

>_四元数一个主要的用途在于插值方便_


变换中的MVP,模型变换，视角变换，投影变换

![MVP变换之前的情况](./Game101Pic/MVP变换之前的情况.png)

![MVP变换之后的情况，Y为Up, -Z为Lookat](./Game101Pic/MVP变换之后的情况.png)

变换之后处理问题变的简单。

大概步骤：
1. 所有模型和相机移动到原点（Y为Up, -Z为Lookat）
2. 正交/投影变换
3. 缩放到[-1, 1]区间
4. 视口变换

想到正交投影的Z处理，一般会直接弃掉Z, 但标准做法是上面的步骤3，会映射到[-1, 1]的立方体中。

![正交投影的矩阵](./Game101Pic/正交投影的矩阵.png)



透视投影推导这里的思想是先把透视投影四棱锥挤压成正交投影的长方体

![挤压成长方体](./Game101Pic/挤压成长方体.png)


对于视椎体内Z值上平面的每一点，x y变换之后的结果为：

![透视投影推导1](./Game101Pic/透视投影推导1.png)

![透视投影推导2](./Game101Pic/透视投影推导2.png)

因此我们知道（x, y, z, 1）经过矩阵变换后可以得到（nx, ny, ?, z）, 通过这些信息可以大概猜测出矩阵的样子

![透视投影推导3](./Game101Pic/透视投影推导3.png)

![透视投影推导4](./Game101Pic/透视投影推导4.png)

还有4个未知数字，我们已知在挤压过程中有两个不变的现象：

挤压过程中的不变式：
1. n平面不变
2. f平面Z不变

因此（x, y, n, 1）经过矩阵变换后应该得到（x, y, n, z）即（nx, ny, n*n, n）, 想要达到这种效果，4个未知数的前两个必须是0

![透视投影推导5](./Game101Pic/透视投影推导5.png)

再利用不变式2，得到剩余两个未知数的数值：

![透视投影推导6](./Game101Pic/透视投影推导6.png)

透视转正交的矩阵为：

![透视转正交的矩阵形式](./Game101Pic/透视转正交的矩阵形式.png)

作业：四棱锥中的任意点变换之后Z是靠近相机还是远离相机？

答案：远离

![Z轴上的一点经过变换](./Game101Pic/MVP变换作业1.png)

计算出的Z与X相减得到：

![Z轴上的一点经过变换](./Game101Pic/MVP变换作业2.jpg)


为什么不是Z不变? 很多人都有这样的疑问，我们按照上面的思路可以计算一下。

如果满足以上所有条件并且Z在转换过程中不变的话会得到下面这个矩阵结果：

![MVP变换作业思考](./Game101Pic/MVP变换作业思考.png)

可以看到这个矩阵中夹带了一个变量z，是一个随着向量不同而时刻变化的矩阵，这不是一个由n和f等常量组成的矩阵，因此一开始的假设(假设一定是一个矩阵并且矩阵各项由已知常量组成)就决定了Z肯定要变化的。

# (5) Rasterization 1 (Triangles)

之前定义视椎体需要用到n, f, l, r, t, b六个变量，实际中只需宽高比(Aspect ratio)和FOV(垂直方向)即可。

![定义视椎体所需的变量](./Game101Pic/定义视椎体所需的变量.png)

l，r, t, b都可以通过宽高比和FOV转换得到(n, f需要知道才能得到四棱锥的信息)：

![通过宽高比和FOV计算其他参数](./Game101Pic/通过宽高比和FOV计算其他参数.png)

光栅化的意思就是画到屏幕上

上一节经过MVP变换后得到[-1, 1]的立方体，现在需要做最后的视口变换，即变换到原点(0, 0)在左下角，宽高为Width, Height的屏幕空间上(Z暂时不做任何处理)：

![视口变换](./Game101Pic/视口变换1.png)

![视口变换](./Game101Pic/视口变换2.png)


>_显示屏幕是如何显示出来内容的？显存中有一块内存区域，我们可以告诉显卡现在哪块内存用于映射到屏幕上(可以利用双缓存)_

三角形的优势：

* 最简单基础的多边形
* 其他多边形可以分解成若干个三角形
* 一定同面
* 内外定义清晰
* 三个顶点有不同的属性，内部可以平滑插值
  
视口变换后我们得到了需要显示的若干些三角形，接下来的问题是判断**像素和三角形的位置关系**，更准确的说是像素的中心点和三角形的位置关系；

采样是一个把函数离散化的过程。

我们定义一个采样的函数：判断某个像素点是否在某个三角形内：

func = inside(tri, x, y)

有了这个采样函数后，我们可以遍历整个屏幕所有的像素点，查询每个像素中心点是否在三角形内：

![采样的简单过程](./Game101Pic/采样的简单过程.PNG)

如何判断一个点是否在三角形内呢？三角形ABC和点P，如果AB叉乘AP, BC叉乘BP, CA叉乘CP结果的Z分量同方向则在三角形内，否则三角形外

上面提到了对于每个三角形都要遍历所有像素点，这里有一个加速方法是只遍历三角形的AABB包围盒：

![只遍历三角形AABB的区域](./Game101Pic/只遍历三角形AABB的区域.PNG)

通过遍历我们想要在屏幕上显示这个三角形：

![想要显示的三角形](./Game101Pic/想要显示的三角形.PNG)

通过采样计算后得到的是：

![采样后得到的实际结果](./Game101Pic/采样后得到的实际结果.PNG)

这就引出了图形学一直致力解决的一个问题：抗锯齿(反走样)技术，根源在于采样率不够。

![典型的锯齿问题](./Game101Pic/典型的锯齿问题.png)

>_问题：所以光栅化的过程是遍历视口变换后的所有三角形，对于每个三角形都要遍历所有像素点，查询该像素点是否在三角形内？_


# （6）Rasterization2(Antialiasing and Z-Buffering)

这里做了一个很有意思的试验，把偶数行列数据抽掉就会删除走样问题，**根源在于信号在很高频地变化而采样率太低**

![摩尔纹](./Game101Pic/摩尔纹.PNG)

先说结论：**先模糊再采样可以很好的解决走样问题**

下面两幅图做下对比：

直接采样可以看到像素点非红即白，这会造成走样问题。

![像素点非红即白](./Game101Pic/像素点非红即白.PNG)

先模糊再采样可以看到三角形边缘位置有红白的中间色

>_可以理解成锯齿边缘不再是那么硬的转换了，而是有过渡色了_

![先模糊再采样](./Game101Pic/先模糊再采样.PNG)

这里提到先采样再模糊是错误的做法。

![先采样后模糊是错误的方法](./Game101Pic/先采样后模糊是错误的方法.PNG)

接下来花了很长的时间来解释如何从信号处理的角度解释什么是走样，什么情况下会出现走样。

任何函数f(x)都可以进行傅里叶展开，即任何函数都可以变换为sin(x)和cos(x)的组合：

![傅里叶变换概述](./Game101Pic/傅里叶变换概述.PNG)

我们可以对任何函数f(x)进行傅里叶变换得到F(x)，又可以对F(x)进行反傅里叶变换变回f(x)

![傅里叶变换和反傅里叶变换](./Game101Pic/傅里叶变换的反傅里叶变换.PNG)

最大的意义在于**时域到频域的相互转换**

信号处理的角度下认为什么是走样呢？在一个给定的采样率下，无法区分两条不同频率的信号时，这种现象就叫走样。

![信号处理的角度理解走样](./Game101Pic/信号处理的角度理解走样.PNG)

## 滤波器就是处理掉某种频率的信息

接下来我们对图片做傅里叶变换，可视化的说明高频和低频

![对图片应用傅里叶变换](./Game101Pic/对图片应用傅里叶变换.PNG)

中心的光亮图是低频信息，而外边的白线和白点是高频信息

我们手动把右边的低频数据抹掉然后再反傅里叶变换回图片上，可以得到如下结果：

![高通滤波器](./Game101Pic/高通滤波器.PNG)

可以看到一些图片中的边缘数据保留了下来，这就说明**高频信息对应的是数据发生突变的那部分信息**，对应到图片就是轮廓数据。

继续看下低通滤波器的效果：

![低通滤波器](./Game101Pic/低通滤波器.PNG)

低通滤波器的效果就是做了类似模糊操作的处理。

## 滤波器也是一种卷积(加权平均)

这里的卷积就是图像处理中的卷积核，是一种狭义的解释

![卷积的一种狭义解释](./Game101Pic/卷积的一种狭义解释.png)

**卷积定理：两个函数时域上的卷积等于频域上的乘积，反之亦然**

![卷积定理的例子](./Game101Pic/卷积定理的例子.png)

可以看到上面使用卷积核在时域上做了卷积操作，我们也可以先将图片通过傅里叶变换转换到频域上，同时也将卷积核做傅里叶变换，然后将这两个结果相乘，然后再反傅里叶变换也能得到相同的结果。

## 采样就是重复频域上的内容

![采样就是重复频域上的内容](./Game101Pic/采样就是重复频域上的内容.png)

左边图就是两个函数时域上的乘积，右边是他们频域上的卷积，右下角的图可以看到采样就是重复频域上的内容，接下来看下信号处理的角度是如何判断是否产生走样的。

![频域内容发生重叠就必然产生走样](./Game101Pic/频域内容发生重叠就必然产生走样.png)

**只要重复频域上的内容发生了重叠就必然会产生走样**

知道了产生的原因，我们接下来看下如何解决走样问题

## 反走样

![反走样的具体办法](./Game101Pic/反走样的具体办法.PNG)

一种是增加采样率，这样在Repeat Content时间隔会增加，或者采用高分辨率显示设备，这种代价比较昂贵。另外一种就是让区域内容变的“窄”一些，办法就是去掉高频内容，即模糊操作。

![先变窄然后再重复](./Game101Pic/先变窄然后再重复.PNG)

具体到反走样步骤如下：

![反走样具体步骤1](./Game101Pic/反走样具体步骤1.PNG)

![反走样具体步骤2](./Game101Pic/反走样具体步骤2.PNG)

![反走样具体步骤3](./Game101Pic/反走样具体步骤3.PNG)

就是不再简单的判断像素中心点在三角形内就是红色，不在就是白色，而是看覆盖面积是多少，面积作为权重计算颜色(白色到红色), 通过覆盖面积计算颜色值其实本质也是一种卷积核，覆盖面积如何粗略计算或者说这个卷积核长什么样子，可以参考下面的具体反走样应用MSAA

## Antialiasing By Supersampling(MSAA)

不同的MSAA设置其实就是设置卷积核是什么样子，具体原理还是上面所提到的。

![MSAA4X4的卷积核](./Game101Pic/MSAA4X4的卷积核.PNG)

以MSAA 4X4为例，就是把一个像素点又分成了16个更小的像素点，分别判断这16个像素点是否在三角形内就可以这个大像素点的覆盖面积，然后就是计算最终颜色

>_游戏引擎中的MSAA 4X指的是4个采样点，即2X2_

![MSAA步骤1](./Game101Pic/MSAA步骤1.PNG)

![MSAA步骤2](./Game101Pic/MSAA步骤2.PNG)

![MSAA步骤3](./Game101Pic/MSAA步骤3.PNG)

![MSAA步骤4](./Game101Pic/MSAA步骤4.PNG)

![MSAA步骤5](./Game101Pic/MSAA步骤5.PNG)

![MSAA步骤6](./Game101Pic/MSAA步骤6.PNG)

## 其他有效的办法

FXAA (Fast Approximate AA) 直接对走样进行类似图片反走样的处理

FXAA是快速近似抗锯齿的简称，它是一种简单而高效的抗锯齿方式，对图形边缘进行后处理。它不需要访问深度缓冲或多重采样缓冲，只需要分析每个像素及其邻域信息，识别出锯齿边缘，并对其进行模糊化处理。

TAA(Temporal Anti-Aliasing)的原理是利用相机抖动和历史帧信息来增加像素的采样数。具体来说，对于每一帧游戏画面，相机会在0.x~1像素范围内随机偏移，这样就可以得到当前像素的多个子像素信息。然后，将当前帧和历史帧进行加权融合，得到当前像素的最终颜色。这样就相当于在时域上进行了超采样，提高了图像的分辨率和清晰度。

DLSS的全称是Deep Learning Super Sampling，翻译成中文就是深度学习超级采样，它的作用是通过降低游戏内的渲染分辨率，同时再通过人工智能算法模型和AI加速硬件单元（Tensor Core）来拉伸输出画面，提高显示分辨率，例如使用1080P的渲染分辨率再通过AI算法和Tensor Core运算输出4K（2160P）的显示分辨率，以此来达成提升帧数的目的

# （7）Shading 1 (Illumination, Shading and Graphics Pipeline)

通过上面的步骤我们有很多三角形需要绘制，还肯定有若干些三角形发生重叠，那么最终某个像素是显示哪个三角形上的颜色呢？这就是处理可见性或者遮挡关系。

## 画家算法

从Z远处的地方开始画，然后画偏近的，重复这个过程。

![画家算法](./Game101Pic/画家算法.PNG)

需要先排序，然后又远到近开始画，n个三角形先按照z排序，算法复杂度O(nlg(n)), 但有一种情况无法处理：

![画家算法无法处理的情况](./Game101Pic/画家算法无法处理的情况.PNG)

这就引入了图形学常用的深度缓存算法

## 深度缓存

深度缓存算法有几个要点：

1. 存储的是每个**像素**上的最小深度而不是三角形
2. 运算过程中有两个buffers, 一个是framebuffer存储颜色值，一个是depthbuffer(z-buffer)存储最小深度值
3. framebuffer和depthbuffer是同时生成的(framebuffer肯定要利用depthbuffer的数据决定最终颜色值)
4. 为了简单，我们约定buffer中存储的都是正值，并且越小说明离相机越近

framebuffer和depthbuffer最终生成的效果图：

![FrameBuffer和DepthBuffer](./Game101Pic/FrameBuffer和DepthBuffer.PNG)

深度缓存伪代码如下，可以看到framebuffer正是利用深度缓存才能确定最终这个像素点最终的颜色值：

![深度缓存伪代码](./Game101Pic/深度缓存伪代码.PNG)

一个示例：

![深度缓存示例](./Game101Pic/深度缓存示例.PNG)

深度缓存的几个特点：
1. 算法复杂度为O(n),因为一个三角形可覆盖的像素点是常量，n个三角形需要判断的次数为常量*n
2. 算法无序也是表现正确的，因此不用提前排序
3. GPU硬件都会实现深度缓存算法

>_注意：如果反走样使用了类似MSAA算法的话，在做深度缓存的时候也需要考虑这些采样点而不是单个像素了_


目前为止，我们能通过MVP变换将三角形渲染到屏幕上

![目前所学的内容](./Game101Pic/目前所学的内容.PNG)

如果这时直接填充颜色的话，会得到如下效果：

![无光照的错误显示](./Game101Pic/无光照的错误显示.PNG)

我们期望的是下面这个结果：

![有明暗变化的正确结果](./Game101Pic/有明暗变化的正确结果.PNG)

这就引出了我们要学的Shading, 本节课关于Shading的定义就是：**给不同物品应用不同材质就叫做Shading**

先讲一个最简单的Shading模型即Blinn-Phong Reflectance Model（布林-冯反射模型）

观察下面的图，可以看到茶杯上有三种不同光照表现，在光源一面的地方，接收光的能量最多，反射的也多，这里产生了高光，侧边的地方光线反射到了四面八方产生了漫反射，背面的地方没有直接接收到光照，而是通过其他墙面间接接收到了光照，这种光叫做环境光或者间接光照

![高光漫反射环境光](./Game101Pic/高光漫反射环境光.png)

"Shading Is Local"的含义是**我们在给物体着色时会把这个点看成一个单位平面并且不考虑其他物体的影响(跟光源之间是否有障碍物等等)**，我们考虑的信息有：

* 当前着色点到观察点之间的单位向量v
* 当前着色点的法向量n(单位平面的朝外垂直单位向量)
* 当前着色点到光源(可能很多光源)之间的单位向量l
* 当前着色点的属性（颜色，光泽度/粗糙度等）

下图可以看到接收的能量多少(物体明暗程度)与n和l的cos(θ)有关

![接收的能量与夹角有关](./Game101Pic/接收的能量与夹角有关.PNG)

跟物体接收能量多少相关的还有跟光源之间的距离，光源向外以球型向外辐射能量，离光源越近，单位面积内接收的能量越多，我们知道球的表面积公式是4πr²，如果定义半径1的球体单位面积接收的能量为I,我们需要求半径r单位面积接收的能量，我们假设能量守恒，即4π(1)² * I = 4πr² * X，所以X = I/r²，因此接收的能量跟r²成反比。

![光源辐射后单位面积的能量](./Game101Pic/光源辐射后单位面积的能量.PNG)

通过上面这些分析我们得出一个漫反射模型：

![漫反射模型](./Game101Pic/漫反射模型.PNG)

三个地方注意：

1. max(0, l·n)处理背面的情况
2. kd是一个漫反射系数，0表示吸收不反射，显示就暗，1表示全部反射，显示就亮，也可以扩充为vector，表示颜色(rgb三个通道可以定义就是r,g,b的反射率)
3. 可以看到与向量v无关，这正符合漫反射的定义，因为漫反射反射到各个方向概率是一样的，因此从各个角度看都是一样的

![明暗随着kd不同而不同](./Game101Pic/明暗随着kd不同而不同.PNG)