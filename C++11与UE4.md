## 右值引用
想要理解这个概念，需要先理解左值，右值以及引用
* 左值应该理解为变量，可以放置在等号左侧的，有持久的状态且有地址的，当然了有地址了就知道值了，所以说需要右值的形参可以传入左值为实参; 需要特别注意的是**任何类型的变量是左值**，即使这个变量是T&&的

* 右值可以理解为常量或者说常量表达式(比如i*32)，代表这个变量即将被销毁，只能放置在等号的右侧，无地址有值的，比如 a= 1;中的1，1有数值无地址

* 左值引用和右值引用都是引用，都是某些值的别名，右值引用本身并没有改变数值或者偷偷传递数据，左值引用是左值的别名，右值引用是右值的别名，仅此而已！ 

## std::move与MoveTemp
为什么右值引用对于大多数人来讲难以理解呢，我应该主要跟std::move函数有关，但可笑的是，其实std::move功能也很简单，它的作用就是把传入的左值返回对应的右值引用，仅此而已，当然了，转换为了右值引用就意味着这个变量可能会被销毁(因为右值就代表着暂时的，即将被销毁的)，所以C++ Primer提到调用std::move后不可以再使用源数据的数值，因为没有保障了! 但std::move自己本身就没有做转移数据的操作，它的作用仅仅是类型转换而已，那么这一切都是谁干的呢？**移动构造函数，移动赋值函数！** 对就是这两个函数做了转移数据的实现，转换为右值引用类型后才会准确地触发移动函数而不是拷贝函数！

这里有个有意思的代码:

```C++
struct DataInfo
{
    int a;
    string b;
    
    DataInfo()
    {
        a = 10;
        b = "Hello World!";
    }
};

int main(int argc, char* argv[])
{
    DataInfo Info1;

    DataInfo Info2 = std::move(Info1);
    
    return 0;
}
```
运行可以发现，Info2中的b变成了Hello World！Info1中的b变成空的了！不是说std::move不会窃取数据吗？ DataInfo Info2 = std::move(Info1);这段代码我们要拆成两步，第一步std::move调用后会返回DataInfo的右值引用类型，第二步是触发DataInfo的构造函数，因为传入的是右值引用类型，所以应该触发DataInfo(DataInfo &&)的移动构造函数，但是，我们的DataInfo(DataInfo &&)并没有实现呀！问题就处在这里了，因为会**触发默认的移动构造函数！**为了更直观的感受下，我们的代码做下改变：

```C++
struct MyString
{
    int a;
    MyString(): a(1){}
    MyString(MyString && r)
    {
        printf("My String Move Contructor!");
        a = 2;
    }
};

struct DataInfo
{
    int a;
    string b;
    MyString c;
    
    DataInfo()
    {
        a = 10;
        b = "Hello World!";
    }
};

int main(int argc, char* argv[])
{
    DataInfo Info1;

    DataInfo Info2 = std::move(Info1);
    
    return 0;
}
```
运行后我们发现My String Move Contructor!打印出来了，**说明默认移动构造函数会触发每个变量的移动构造函数**，而string是实现了移动构造函数的，这就可以解释上面的现象了！

MoveTemp几乎等同于std::move，只不过对于两种传入类型做了静态检查，传入值本身是右值引用，这显然调用MoveTemp是多余的;另一种是const object，这种类型做转换是错误的，因为移动构造函数本身需要修改右值引用中的数据,比如数据指针设置为nullptr

右值引用和std::move的其他参考资料: [一文读懂C++右值引用和std::move](https://zhuanlan.zhihu.com/p/335994370)

## 智能指针

## lambda

## 拷贝构造函数，拷贝赋值函数，移动构造函数，移动赋值函数

## 内联

## 各种Cast

各种指针:
TObjectPtr


虚幻引擎必知项:
序列化与序列化，编辑器编辑与Runtime的关系
反射系统以及UBT
UProperty原理以及各个设置
智能指针