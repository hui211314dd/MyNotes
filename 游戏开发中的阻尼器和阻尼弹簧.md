# 前言
本篇翻译的是Daniel Holden的第二篇文章，之前一篇是[Motion Matching 中的代码驱动移动和动画驱动移动](https://zhuanlan.zhihu.com/p/432663486)

如果你看过MotionMatching的文章，那你必然会经常听见这个词“Spring”或者“Spring Damper”，中文即弹簧阻尼，Daniel Holden从简单的Damper(阻尼器)讲到SpringDamper(弹簧阻尼)，然后延伸到游戏开发中常用的Critical Spring Damper(临界弹簧阻尼)，最后给出了很多开发中的例子。Daniel Holden本身喜欢写作，可以看到他的文笔特别流畅，方案抉择背后的原因，方案的原理以及推导特别清晰明了，通篇读完后收获颇丰，翻译此篇希望对你也有所帮助~

当然了，我能力有限，如有出现错误，欢迎批评指正！

Daniel Holden最近宣布从育碧跳到了Epic Games，担任Principal Animation Programmer，他主要研究的方向是机器学习和角色动画相关，UE5本身就内置了大量机器学习的模块，相信Daniel一定能将UE5的机器学习和角色动画推向新的高度，恭喜~~

(前几个月，[《荣耀战魂》 中的MotionMatching](https://zhuanlan.zhihu.com/p/401890149)的Simon Clavet也跳槽去Cloud Chamber做生化奇兵了，育碧损失两员大将了...)

![pic](./SpringPic/1.jpg)

# 正文
Springs和游戏开发有什么关系呢？如果你有此疑问，那说明你来对地方了，本篇会讲述大量与Springs相关的东西。即使你之前使用过Springs的功能，但我猜，Springs本身各种复杂的方程式你可能也从来没有碰过，数学公式虽然棘手，但Springs本身特别有趣，而且也用途广泛，在计算机应用中随处可见, 如果你对游戏开发，动画，物理模拟感兴趣的话，我相信你肯定能从Springs中收获良多。

接下来我们会说到what they are, what they do, how they do it, and what they can be used for

我们先介绍第一个概念：The Damper

## The Damper
作为一个游戏开发者，你肯定碰到过这个场景：我们意识到某个物体应该在另一个位置(可能是服务器同步过来的新位置或者之前再处理其他事情现在这个时候需要移动该物体了)，我们希望的是平滑地移向目标位置而不是瞬切过去

一个简单可行的办法是使用blend函数传入当前位置x以及目标位置g并且传入一个固定的factor比如每帧0.1

C++的代码可能像下面这个样子，代码处理的是单个float，如果想应用到position上, 单独应用每个vector分量即可

```
float lerp(float x, float y, float a)
{
    return (1.0f - a) * x + a * y;
}

float damper(float x, float g, float factor)
{
    return lerp(x, g, factor);
}
```

每帧调用时我们都应用固定的factor， 这样我们就能够平滑地向目标点靠近并且不会发生瞬切，我们甚至可以通过调整factor的值来控制插值的速度

```
x = damper(x, g, factor);
```

下面的视频可以看到可视化的运动，x轴代表时间，y轴代表物体的位置

{视频 damper.m4v}

```
 注:这里有几个问题大家想下
 1. 速度在视频内是如何表示的？
 2. lerp明明是线性插值，为什么视频里的表现是曲线呢？哪里调用跟lerp常规使用不太一样？这样调用有什么优势？

 我建议往下阅读前先想想这几个问题
```

但这个方案有个问题，如果调整游戏的帧率(timestep)会发现damper行为会不一致，简单来说，帧率越低那么物体运动的就越慢...

{视频damper_dt.m4v}

仔细想想这种表现是说的通的，因为每秒60 fps比每秒30fps在调用次数上要多一倍，所以60fps的趋向目标位置更快一些。一个简单的做法是factor乘以dt整体作为factor,这样的话，dt大的趋向目标位置也快了~

```
float damper_bad(float x, float t, float damping, float dt)
{
    return lerp(x, t, damping * dt);
}
```

表面上看起来工作良好，但其实还存在着两个比较大的问题，首先我们需要设置一个叫damping的参数，这个参数很难理解，第二个问题更严重，如果我们设置damping或者dt太大(比如damping * dt > 1),那么效果会变得极其不稳定...

{视频 damper_bad.m4v}

当然我们也可以利用clamping将damping * dt限定在小于1的范围内，但是这里面还存在着一个问题，我们假设damping * dt等于0.5，我们会发现调用两次产生的结果与dt乘以2调用一次产生的结果不一致，调用两次的结果是趋向目标位置75%的位置，dt剩余2表示damping * dt * 2 = 1产生的结果是直接移动到目标位置，如何修复这种问题呢？ 
### The Implicit Damper
我们假设dt为1，goal为0，factor为0.5，我们调查下x数值变化的图像表：

![decay.png](./SpringPic/decay.png)

可以看到当多次调用lerp时效果是以指数的形式向目标位置靠近：

![decay.png](./SpringPic/exp_excay.png)

如果传入lerp的factor为0.5，方程式可以写为$x_t = 0.5^{t}$.看起来是一种指数关系，这种关系是如何产生的呢？我们利用递推公式来揭示这种关系~

#### Recurrence Relation
我们先定义一个单独的变量$y$满足$y = 1 - damping * ft$,目的是为了后面表达式能够简化一些。假定$ft$是一个固定值，$dt$假设为$1/60$这样的小值，我们将lerp函数进行展开：

![png](./SpringPic/1.png)

我们从$t + 1$推导到$t + 2$

![png](./SpringPic/2.png)

如果我们继续推导，则发现方程的范式就出现了

![png](./SpringPic/3.png)

通用公式如下：

![png](./SpringPic/4.png)


## The Spring Damper

### The Implicit Spring Damper

### Over, Under, and Critical Damping

### The Half-life and the Frequency

### The Critical Spring Damper

## Applications

### Smoothing

### Filtering

### Controllers

### Inertialization

### Interpolation

### Resonance

## Other Springs

### Double Spring

### Timed Spring

### Velocity Spring

### Quaternion Spring

## Source Code

(正文完)
# 我的总结

## 阅读前的疑问以及解答
1. Spring与速度的联系？
2. 正常图像中的速度如何表示的？
3. Spring与惯性化插值的特点，区别和应用场景？
4. 惯性化插值完成时刚好速度，加速度为0吗？
5. Spring是否速度，加速连续？
6. 现在的位置为x,速度为v1,目标位置是g,目标速度是v2,SpringDamper和惯性化插值是否都可以使用？
## 题外话
读懂文章太难了，纯数学角度大致了解Spring模型还是不错的~没有胡克定律之类的
数学重要性以及建议
DecaySpringDamper原理上与Inertialization相当类似，甚至数学推导

# 其他参考资料
https://www.youtube.com/watch?v=BYyv4KTegJI&list=PL2e4mYbwSTbbHAJT7OdK5mv-idhlLOTl0&index=12

https://zhuanlan.zhihu.com/p/412291354

https://zhuanlan.zhihu.com/p/380222928

https://zhuanlan.zhihu.com/p/73284882

https://zhuanlan.zhihu.com/p/390476167

游戏编程精粹4-1.10，用临界阻尼实现慢入慢出的平滑，勘误图1.10.1