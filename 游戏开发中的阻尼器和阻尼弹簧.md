# 前言
本篇是我翻译Daniel Holden的第二篇文章，之前一篇是[Motion Matching 中的代码驱动移动和动画驱动移动](https://zhuanlan.zhihu.com/p/432663486)

如果你看过MotionMatching的文章，那你必然会经常听见这个词“Spring”或者“Spring Damper”，中文即弹簧阻尼，Daniel Holden从简单的Damper(阻尼器)讲到SpringDamper(弹簧阻尼)，然后延伸到游戏开发中常用的Critical Spring Damper(临界弹簧阻尼)，最后给出了很多开发中的例子。Daniel Holden本身喜欢写作，可以看到他的文笔特别流畅，方案抉择背后的原因，方案的原理以及推导特别清晰明了，读完后收获颇丰，翻译此篇希望对你也有所帮助~

当然了，我能力有限，如有出现错误，欢迎批评指正！

Daniel Holden最近宣布从育碧跳到了Epic Games，担任Principal Animation Programmer，他主要研究的方向是机器学习和角色动画相关，UE5本身就内置了大量机器学习的模块，相信Daniel一定能将UE5的机器学习和角色动画推向新的高度，恭喜~~

(前几个月，[《荣耀战魂》 中的MotionMatching](https://zhuanlan.zhihu.com/p/401890149)的Simon Clavet也跳槽去Cloud Chamber做生化奇兵了，育碧损失两员大将了...)

![pic](./SpringPic/1.jpg)

# 正文
Springs和游戏开发有什么关系呢？如果你有此疑问，那说明你来对地方了，本篇会讲述大量与Springs相关的东西。即使你之前使用过Springs的功能，但我猜，Springs本身各种复杂的方程式你可能也从来没有碰过，数学公式虽然棘手，但Springs本身特别有趣，而且也用途广泛，在计算机应用中随处可见, 如果你对游戏开发，动画，物理模拟感兴趣的话，我相信你肯定能从Springs中收获良多。

接下来我们会说到what they are, what they do, how they do it, and what they can be used for

我们先介绍第一个概念：The Damper

## The Damper
作为一个游戏开发者，你肯定碰到过这个场景：我们意识到某个物体应该在另一个位置(可能是服务器同步过来的新位置或者之前再处理其他事情现在这个时候需要移动该物体了)，我们希望的是平滑地移向目标位置而不是瞬切过去

一个简单可行的办法是使用blend函数传入当前位置x以及目标位置g并且传入一个固定的factor比如每帧0.1

C++的代码可能像下面这个样子，代码处理的是单个float，如果想应用到position上, 单独应用每个vector分量即可

```
float lerp(float x, float y, float a)
{
    return (1.0f - a) * x + a * y;
}

float damper(float x, float g, float factor)
{
    return lerp(x, g, factor);
}
```

每帧调用时我们都应用固定的factor， 这样我们就能够平滑地向目标点靠近并且不会发生瞬切，我们甚至可以通过调整factor的值来控制插值的速度

```
x = damper(x, g, factor);
```

下面的视频可以看到可视化的运动，x轴代表时间，y轴代表物体的位置

{视频 damper.m4v}

```
 注:这里有几个问题大家想下
 1. 速度在视频内是如何表示的？
 2. lerp明明是线性插值，为什么视频里的表现是曲线呢？哪里调用跟lerp常规使用不太一样？这样调用有什么优势？

 我建议往下阅读前先想想这几个问题
```

但这个方案有个问题，如果调整游戏的帧率(timestep)会发现damper行为会不一致，简单来说，帧率越低那么物体运动的就越慢...

{视频damper_dt.m4v}

仔细想想这种表现是说的通的，因为每秒60 fps比每秒30fps在调用次数上要多一倍，所以60fps的趋向目标位置更快一些。一个简单的做法是factor乘以dt整体作为factor,这样的话，dt大的趋向目标位置也快了~

```
float damper_bad(float x, float t, float damping, float dt)
{
    return lerp(x, t, damping * dt);
}
```

表面上看起来工作良好，但其实还存在着两个比较大的问题，首先我们需要设置一个叫damping的参数，这个参数很难理解，第二个问题更严重，如果我们设置damping或者dt太大(比如damping * dt > 1),那么效果会变得极其不稳定...

{视频 damper_bad.m4v}

当然我们也可以利用clamping将damping * dt限定在小于1的范围内，但是这里面还存在着一个问题，我们假设damping * dt等于0.5，我们会发现调用两次产生的结果与dt乘以2调用一次产生的结果不一致，调用两次的结果是趋向目标位置75%的位置，dt剩余2表示damping * dt * 2 = 1产生的结果是直接移动到目标位置，如何修复这种问题呢？ 
### The Implicit Damper
我们假设dt为1，goal为0，factor为0.5，我们调查下x数值变化的图像表：

![decay.png](./SpringPic/decay.png)

可以看到当多次调用lerp时效果是以指数的形式向目标位置靠近：

![decay.png](./SpringPic/exp_excay.png)

如果传入lerp的factor为0.5，方程式可以写为$x_t = 0.5^{t}$.看起来是一种指数关系，这种关系是如何产生的呢？我们利用递推公式来揭示这种关系~

#### Recurrence Relation
我们先定义一个单独的变量$y$满足$y = 1 - damping * ft$,目的是为了后面表达式能够简化一些。假定$ft$是一个固定值，$dt$假设为$1/60$这样的小值，我们将lerp函数进行展开：

![png](./SpringPic/1.png)

我们从$t + 1$推导到$t + 2$

![png](./SpringPic/2.png)

如果我们继续推导，则发现方程的范式就出现了

![png](./SpringPic/3.png)

通用公式如下：

![png](./SpringPic/4.png)

指数表达式出现了，我们整理下公式然后用lerp函数表示: 

![png](./SpringPic/5.png)

再做一次调整把指数变成负数(注：数据稳定性？)

![png](./SpringPic/6.png)

需要注意的是$n$代表$ft$的次数，如果任意给$dt$需要通过$n = dt/ft$转成$n$, C++代码如下：

```
float damper_exponential(
    float x,
    float g, 
    float damping, 
    float dt, 
    float ft = 1.0f / 60.0f)
{
    return lerp(x, g, 1.0f - powf(1.0 / (1.0 - ft * damping), -dt / ft));
} 
```

我们来看下它的表现，可以看到跟之前的表现完全相同，并且即使我们将$dt$和$damping$设置的很大表现也是稳定的

{视频 damper_exponent.m4v}

所以我们的问题是解决了吗？emm...我们实质上是通过damper匹配一个特定的timestep从而允许衰减速率(rate of decay)可变的，本例中$1 - ft * damping$就是衰减速率，它表示经过$ft$时间后移向目标位置的距离比例，当我们的$ft$足够小时$1 - ft * damping$永远不会超过1，那么它的表现会保持稳定

#### The Half-Life
我们用另一种更好的办法解决上面的问题，相对于固定timestep值，我们可以选择固定衰减速率这个值从而让timestep可变. 初听起来有点怪但实践中可以发现这样处理可以把事情变得更简单！方法很简单，我们将衰减速率设置为$0.5$,我们通过控制一个叫half-life的变量，这个变量大致表示移动到目标点一半距离消耗的时间：

![png](./SpringPic/7.png)

这种方式简化了我们的代码并且给了一个相当直观的参数控制damper,现在我们再不用担心是否damping设置的值太大了或者ft是否足够小...

```
float damper_implicit(float x, float g, float halflife, float dt)
{
    return lerp(x, g, 1.0f - powf(2, -dt / halflife));
}
```

为了代码整洁，我们把底数变成$e$,通过$dt * ln(2)$即可完成换底，其中$ln(2) = 0.69314718056$,最后我们添加epsilon避免halflife太小时的除零问题

```
float damper_implicit(float x, float g, float halflife, float dt, float eps=1e-5f)
{
    return lerp(x, g, 1.0f - expf(-(0.69314718056f * dt) / (halflife + eps)));
}
```

通过上面公式的转换我们发现另外一个有意思的事情，那就是之前我们改变衰减速率的方式和在指数上缩放$dt$的方式是没有区别的，通过改变衰减速率达成的效果完全可以通过改变halflife实现！

这里还有一个技巧是，通过泰勒公式的截断式粗略计算e的负指数

```
float fast_negexp(float x)
{
    return 1.0f / (1.0f + x + 0.48f*x*x + 0.235f*x*x*x);
}
```

至此，我们将一个不稳定的damper进化成了一个快速稳定并且参数清晰明了的damper!我们看下它的表现

{视频 damper_implicit.m4v}

完美~~
## The Spring Damper
implicit damper虽然能够处理一些需求但它存在一个很严重的问题，那就是当目标位置快速发生变化时会产生运动的不连续，通过上面的视频可以看到当物体正向某一个方向移动时目标位置切到了反方向这时候就会发生运动突变

问题主要原因在于速度的不连续，无论之前的帧发生了什么damper始终是直接向目标位置移动的，我们看下应该如何修复这个问题. 我们回过头来看下之前写的bad damper的例子从中挖掘一些有用的信息

![png](./SpringPic/8.png)

我们可以看出来有点像物理公式而$damping * (g - x_t)$代表速度

![png](./SpringPic/9.png)

这个系统看起来像是一个质点的速度始终为当前位置到目标位置的比例值，这就解释了为什么会发生不连续的原因，速度始终与当前位置和目标位置相关，丝毫没有考虑到之前的速度信息

如果我们不再直接设置速度值，取而代之的是平滑地改变速度值是不是就可以解决我们的问题了呢？比如我们可以在原来速度的基础上加上一个能趋势我们移向目标位置的速度，这个值通过一个$stiffness$的参数控制缩放.

![png](./SpringPic/10.png)

这样就会出现另外一个问题，质点只有经过目标位置后才会减速导致质点被拉到另外一个方向上去了，为了解决这个问题我们添加另外一个参数$q$表示goal  velocity,保证最后能够趋向于这个速度值，这项被$damping$的参数控制

![png](./SpringPic/11.png)

当$q$值很小时我们可以把它看成摩擦项负责减速，当$q = 0$并且$dt * damping = 1$时摩擦项刚好能够抵消完现有速度，随之回归到damper起初的样子

另外一种角度看就是把整体项看成加速度，下面的公式可以很清晰地看出来：

![png](./SpringPic/12.png)

我们假定质点的质量为1，而且我们可以想象成整个过程有两个独立的力，一个力驱使我们把质点移动到目标速度上另外一个力驱使我们把质点移动到目标位置点，$dt$足够小的情况下我们把这些functions合到一起就会模拟出能够速度连续的damped spring，函数如下(使用[半隐式欧拉积分](https://gafferongames.com/post/integration_basics/)):

```
void spring_damper_bad(
    float& x,
    float& v, 
    float g,
    float q, 
    float stiffness, 
    float damping, 
    float dt)
{
    v += dt * stiffness * (g - x) + dt * damping * (q - v);
    x += dt * v;
}
```

看下它的表现:

{视频 springdamper_bad.m4v}

不幸的是，我们又碰到了之前出过的问题，当$dt$足够大并且$stiffness$和$damping$设置到特定数值后效果变得不再稳定，像$stiffness$和$damping$这种不直观的参数又带我们走进了迷雾...

{视频 springdamper_unstable.m4v}

这次我们能不能像处理damper时那样用些数学推导解决问题呢？可以是可以，不过从这里开始，事情变得有点复杂了...
### The Implicit Spring Damper
如果用简单的递推公式求SpringDamper太过于复杂，所以本次我们换一种思路，我们先猜一个差不多公式，然后基于它计算出相关的参数比如$damping$和$stiffness$

如果我们分析之前spring的运动可以发现它存在两个特点一是指数级衰减趋向于目标位置，还存在振荡，有点像$cos$或者$sin$函数的图像。我们尝试构建一个能够满足这些特点的公式，比如下面这个公式怎么样？

![png](./SpringPic/13.png)

其中$j$代表振幅，$y$代表衰减花费的时间，有点像half-life参数，$t$表示时间，$w$表示振荡的频率，$p$表示振荡的相位，$c$表示垂直轴的偏移，这个公式跟我们看到的Spring行为是相匹配的

再求解这些未知参数之前，我们先对$t$进行求导，分别求出一阶导数$v_t$和二阶导数$a_t$

![png](./SpringPic/14.png)

> 注：这是我推导的详细过程

![png](./SpringPic/15.jpg)

![png](./SpringPic/16.jpg)

公式看起来有点复杂，我们把公式简化下

![png](./SpringPic/17.png)

#### Finding the Spring Parameters
我们会按照如下的办法求解这些未知参数：我们把上面的$x_t$$v_t$以及$a_t$带入到另外一个公式$a_t = s * (g - x_t) + d * (q - v_t)$其中$d = damping$以及$s = stiffness$，我们可以基于此求解出$y, w, c$最后利用这些参数求解出$s, d, q, g$

我们首先对运动公式最一些整理，方便后面使用.

![png](./SpringPic/18.png)

把刚才创建的$x_t,v_t$和$a_t$带入进去：

![png](./SpringPic/19.png)

公式展开把系数为C和S的项合并:

![png](./SpringPic/20.png)

另外有一个事实我们可以利用下，那就是C和S本质就是$cos$和$sin$函数，它们有相同的相位，振幅以及频率，我们假设左项等于0，那么如果右项也等于0的话只能是它们的系数等于0，得到下面三个公式：

![png](./SpringPic/21.png)

求解$c$

利用公式$(1)$可以求解出第一个未知参数$c$!

![png](./SpringPic/22.png)

求解$y$

整理公式$(3)$可以解得参数$y$:

![png](./SpringPic/23.png)

求解$w$

将$y$的解带入公式$(2)$中得到$w$:

![png](./SpringPic/24.png)

Finding the Spring State

现在还有两个未知参数$j, p$,分别表示振幅和相位，不像$y, w, c$,这两个参数是又spring的初始条件决定的，所以我们给定初始位置以及初始速度$x_0, v_0$,我们将$t = 0$带入公式中求$j, p$:

![png](./SpringPic/25.png)

求解$j$

先整理$x_0$关于$p$的公式：

![png](./SpringPic/26.png)

随之带入到$v_0$的公式中:

![png](./SpringPic/27.png)

最后整理公式得到$j$:

![png](./SpringPic/28.png)

因为是平方和平方根的公式，所以符号丢失了，在这个例子中，如果$x_0 - c <0$的话，$j$需要取负值

求解$p$

整理$v_0$关于$j$的公式:

![png](./SpringPic/29.png)

带入到$x_0$公式中求解$p$:

![png](./SpringPic/30.png)

把所有的公式合在一起：

```
float fast_atan(float x)
{
    float z = fabs(x);
    float w = z > 1.0f ? 1.0f / z : z;
    float y = (M_PI / 4.0f)*w - w*(w - 1)*(0.2447f + 0.0663f*w);
    return copysign(z > 1.0f ? M_PI / 2.0 - y : y, x);
}

float squaref(float x)
{
    return x*x;
}

void spring_damper_implicit(
    float& x, 
    float& v, 
    float x_goal, 
    float v_goal, 
    float stiffness, 
    float damping, 
    float dt, 
    float eps = 1e-5f)
{
    float g = x_goal;
    float q = v_goal;
    float s = stiffness;
    float d = damping;
    float c = g + (d*q) / (s + eps);
    float y = d / 2.0f;
    float w = sqrtf(s - (d*d)/4.0f);
    float j = sqrtf(squaref(v + y*(x - c)) / (w*w + eps) + squaref(x - c));
    float p = fast_atan((v + (x - c) * y) / (-(x - c)*w + eps));

    j = (x - c) > 0.0f ? j : -j;

    float eydt = fast_negexp(y*dt);

    x = j*eydt*cosf(w*dt + p) + c;
    v = -y*j*eydt*cosf(w*dt + p) - w*j*eydt*sinf(w*dt + p);
}
```

哇！它动起来了~即便$dt$和$stiffness$数值设置的很大，运动表现依然很稳定，我们利用一些高中的知识就完成了这样复杂的推导~~

{视频 springdamper_implicit.m4v}

### Over, Under, and Critical Damping


### The Half-life and the Frequency

### The Critical Spring Damper

## Applications

### Smoothing

### Filtering

### Controllers

### Inertialization

### Interpolation

### Resonance

## Other Springs

### Double Spring

### Timed Spring

### Velocity Spring

### Quaternion Spring

## Source Code

(正文完)
# 我的总结

## 阅读前的疑问以及解答
1. Spring与速度的联系？
2. 正常图像中的速度如何表示的？
3. Spring与惯性化插值的特点，区别和应用场景？
4. 惯性化插值完成时刚好速度，加速度为0吗？
5. Spring是否速度，加速连续？
6. 现在的位置为x,速度为v1,目标位置是g,目标速度是v2,SpringDamper和惯性化插值是否都可以使用？
## 题外话
读懂文章太难了，纯数学角度大致了解Spring模型还是不错的~没有胡克定律之类的
数学重要性以及建议
DecaySpringDamper原理上与Inertialization相当类似，甚至数学推导

# 其他参考资料
https://www.youtube.com/watch?v=BYyv4KTegJI&list=PL2e4mYbwSTbbHAJT7OdK5mv-idhlLOTl0&index=12

https://www.youtube.com/watch?v=RGOUPe-GfCk

https://zhuanlan.zhihu.com/p/412291354

https://zhuanlan.zhihu.com/p/380222928

https://zhuanlan.zhihu.com/p/73284882

https://zhuanlan.zhihu.com/p/390476167

游戏编程精粹4-1.10，用临界阻尼实现慢入慢出的平滑，勘误图1.10.1