# 前言
本篇翻译的是Daniel Holden的第二篇文章，之前一篇是[Motion Matching 中的代码驱动移动和动画驱动移动](https://zhuanlan.zhihu.com/p/432663486)

如果你看过MotionMatching的文章，那你必然会经常听见这个词“Spring”或者“Spring Damper”，中文即弹簧阻尼，Daniel Holden从简单的Damper(阻尼器)讲到SpringDamper(弹簧阻尼)，然后延伸到游戏开发中常用的Critical Spring Damper(临界弹簧阻尼)，最后给出了很多开发中的例子。Daniel Holden本身喜欢写作，可以看到他的文笔特别流畅，方案抉择背后的原因，方案的原理以及推导特别清晰明了，通篇读完后收获颇丰，翻译此篇希望对你也有所帮助~

当然了，我能力有限，如有出现错误，欢迎批评指正！

Daniel Holden最近宣布从育碧跳到了Epic Games，担任Principal Animation Programmer，他主要研究的方向是机器学习和角色动画相关，UE5本身就内置了大量机器学习的模块，相信Daniel一定能将UE5的机器学习和角色动画推向新的高度，恭喜~~

(前几个月，[《荣耀战魂》 中的MotionMatching](https://zhuanlan.zhihu.com/p/401890149)的Simon Clavet也跳槽去Cloud Chamber做生化奇兵了，育碧损失两员大将了...)

![pic](./SpringPic/1.jpg)

# 正文
Springs和游戏开发有什么关系呢？如果你有此疑问，那说明你来对地方了，本篇会讲述大量与Springs相关的东西。即使你之前使用过Springs的功能，但我猜，Springs本身各种复杂的方程式你可能也从来没有碰过，数学公式虽然棘手，但Springs本身特别有趣，而且也用途广泛，在计算机应用中随处可见, 如果你对游戏开发，动画，物理模拟感兴趣的话，我相信你肯定能从Springs中收获良多。

接下来我们会说到what they are, what they do, how they do it, and what they can be used for

我们先介绍第一个概念：The Damper

## The Damper
作为一个游戏开发者，你肯定碰到过这个场景：我们意识到某个物体应该在另一个位置(可能是服务器同步过来的新位置或者之前再处理其他事情现在这个时候需要移动该物体了)，我们希望的是平滑地移向目标位置而不是瞬切过去

一个简单可行的办法是使用blend函数传入当前位置x以及目标位置g并且传入一个固定的factor比如每帧0.1

C++的代码可能像下面这个样子，代码处理的是单个float，如果想应用到position上, 单独应用每个vector分量即可

```
float lerp(float x, float y, float a)
{
    return (1.0f - a) * x + a * y;
}

float damper(float x, float g, float factor)
{
    return lerp(x, g, factor);
}
```

每帧调用时我们都应用固定的factor， 这样我们就能够平滑地向目标点靠近并且不会发生瞬切，我们甚至可以通过调整factor的值来控制插值的速度

```
x = damper(x, g, factor);
```

下面的视频可以看到可视化的运动，x轴代表时间，y轴代表物体的位置

{视频 damper.m4v}

```
 注:这里有几个问题大家想下
 1. 速度在视频内是如何表示的？
 2. lerp明明是线性插值，为什么视频里的表现是曲线呢？哪里调用跟lerp常规使用不太一样？这样调用有什么优势？

 我建议往下阅读前先想想这几个问题
```

但这个方案有个问题，如果调整游戏的帧率(timestep)会发现damper行为会不一致，简单来说，帧率越低那么物体运动的就越慢...

{视频damper_dt.m4v}

仔细想想这种表现是说的通的，因为每秒60 fps比每秒30fps在调用次数上要多一倍，所以60fps的趋向目标位置更快一些。一个简单的做法是factor乘以dt整体作为factor,这样的话，dt大的趋向目标位置也快了~

```
float damper_bad(float x, float t, float damping, float dt)
{
    return lerp(x, t, damping * dt);
}
```

表面上看起来工作良好，但其实还存在着两个比较大的问题，首先我们需要设置一个叫damping的参数，这个参数很难理解，第二个问题更严重，如果我们设置damping或者dt太大(比如damping * dt > 1),那么效果会变得极其不稳定...

{视频 damper_bad.m4v}

当然我们也可以利用clamping将damping * dt限定在小于1的范围内，但是这里面还存在着一个问题，我们假设damping * dt等于0.5，我们会发现调用两次产生的结果与dt乘以2调用一次产生的结果不一致，调用两次的结果是趋向目标位置75%的位置，dt剩余2表示damping * dt * 2 = 1产生的结果是直接移动到目标位置，如何修复这种问题呢？ 
### The Implicit Damper
我们假设dt为1，goal为0，factor为0.5，我们调查下x数值变化的图像表：

![decay.png](./SpringPic/decay.png)

可以看到当多次调用lerp时效果是以指数的形式向目标位置靠近：

![decay.png](./SpringPic/exp_excay.png)

如果传入lerp的factor为0.5，方程式可以写为$x_t = 0.5^{t}$.看起来是一种指数关系，这种关系是如何产生的呢？我们利用递推公式来揭示这种关系~

#### Recurrence Relation
我们先定义一个单独的变量$y$满足$y = 1 - damping * ft$,目的是为了后面表达式能够简化一些。假定$ft$是一个固定值，$dt$假设为$1/60$这样的小值，我们将lerp函数进行展开：

![png](./SpringPic/1.png)

我们从$t + 1$推导到$t + 2$

![png](./SpringPic/2.png)

如果我们继续推导，则发现方程的范式就出现了

![png](./SpringPic/3.png)

通用公式如下：

![png](./SpringPic/4.png)

指数表达式出现了，我们整理下公式然后用lerp函数表示: 

![png](./SpringPic/5.png)

再做一次调整把指数变成负数(注：数据稳定性？)

![png](./SpringPic/6.png)

需要注意的是$n$代表$ft$的次数，如果任意给$dt$需要通过$n = dt/ft$转成$n$, C++代码如下：

```
float damper_exponential(
    float x,
    float g, 
    float damping, 
    float dt, 
    float ft = 1.0f / 60.0f)
{
    return lerp(x, g, 1.0f - powf(1.0 / (1.0 - ft * damping), -dt / ft));
} 
```

我们来看下它的表现，可以看到跟之前的表现完全相同，并且即使我们将$dt$和$damping$设置的很大表现也是稳定的

{视频 damper_exponent.m4v}

所以我们的问题是解决了吗？emm...我们实质上是通过damper匹配一个特定的timestep从而允许衰减速率(rate of decay)可变的，本例中$1 - ft * damping$就是衰减速率，它表示经过$ft$时间后移向目标位置的距离比例，当我们的$ft$足够小时$1 - ft * damping$永远不会超过1，那么它的表现会保持稳定

#### The Half-Life
我们用另一种更好的办法解决上面的问题，相对于固定timestep值，我们可以选择固定衰减速率这个值从而让timestep可变. 初听起来有点怪但实践中可以发现这样处理可以把事情变得更简单！方法很简单，我们将衰减速率设置为$0.5$,我们通过控制一个叫half-life的变量，这个变量大致表示移动到目标点一半距离消耗的时间：

![png](./SpringPic/7.png)

这种方式简化了我们的代码并且给了一个相当直观的参数控制damper,现在我们再不用担心是否damping设置的值太大了或者ft是否足够小...

```
float damper_implicit(float x, float g, float halflife, float dt)
{
    return lerp(x, g, 1.0f - powf(2, -dt / halflife));
}
```

为了代码整洁，我们把底数变成$e$,通过$dt * ln(2)$即可完成换底，其中$ln(2) = 0.69314718056$,最后我们添加epsilon避免halflife太小时的除零问题

```
float damper_implicit(float x, float g, float halflife, float dt, float eps=1e-5f)
{
    return lerp(x, g, 1.0f - expf(-(0.69314718056f * dt) / (halflife + eps)));
}
```

通过上面公式的转换我们发现另外一个有意思的事情，那就是之前我们改变衰减速率的方式和在指数上缩放$dt$的方式是没有区别的，通过改变衰减速率达成的效果完全可以通过改变halflife实现！

这里还有一个技巧是，通过泰勒公式的截断式粗略计算e的负指数

```
float fast_negexp(float x)
{
    return 1.0f / (1.0f + x + 0.48f*x*x + 0.235f*x*x*x);
}
```

至此，我们将一个不稳定的damper进化成了一个快速稳定并且参数清晰明了的damper!我们看下它的表现

{视频 damper_implicit.m4v}

完美~~
## The Spring Damper

### The Implicit Spring Damper

### Over, Under, and Critical Damping

### The Half-life and the Frequency

### The Critical Spring Damper

## Applications

### Smoothing

### Filtering

### Controllers

### Inertialization

### Interpolation

### Resonance

## Other Springs

### Double Spring

### Timed Spring

### Velocity Spring

### Quaternion Spring

## Source Code

(正文完)
# 我的总结

## 阅读前的疑问以及解答
1. Spring与速度的联系？
2. 正常图像中的速度如何表示的？
3. Spring与惯性化插值的特点，区别和应用场景？
4. 惯性化插值完成时刚好速度，加速度为0吗？
5. Spring是否速度，加速连续？
6. 现在的位置为x,速度为v1,目标位置是g,目标速度是v2,SpringDamper和惯性化插值是否都可以使用？
## 题外话
读懂文章太难了，纯数学角度大致了解Spring模型还是不错的~没有胡克定律之类的
数学重要性以及建议
DecaySpringDamper原理上与Inertialization相当类似，甚至数学推导

# 其他参考资料
https://www.youtube.com/watch?v=BYyv4KTegJI&list=PL2e4mYbwSTbbHAJT7OdK5mv-idhlLOTl0&index=12

https://zhuanlan.zhihu.com/p/412291354

https://zhuanlan.zhihu.com/p/380222928

https://zhuanlan.zhihu.com/p/73284882

https://zhuanlan.zhihu.com/p/390476167

游戏编程精粹4-1.10，用临界阻尼实现慢入慢出的平滑，勘误图1.10.1